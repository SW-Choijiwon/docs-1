
<!DOCTYPE html>
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>Parquet 파일 - Spark 2.4.3 Documentation</title>
        

        

        <link rel="stylesheet" href="css/bootstrap.min.css">
        <style>
            body {
                padding-top: 60px;
                padding-bottom: 40px;
            }
        </style>
        <meta name="viewport" content="width=device-width">
        <link rel="stylesheet" href="css/bootstrap-responsive.min.css">
        <link rel="stylesheet" href="css/main.css">

        <script src="js/vendor/modernizr-2.6.1-respond-1.1.0.min.js"></script>

        <link rel="stylesheet" href="css/pygments-default.css">

    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an outdated browser. <a href="https://browsehappy.com/">Upgrade your browser today</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to better experience this site.</p>
        <![endif]-->

        <!-- This code is taken from http://twitter.github.com/bootstrap/examples/hero.html -->

        <div class="navbar navbar-fixed-top" id="topbar">
            <div class="navbar-inner">
                <div class="container">
                    <div class="brand"><a href="index.html">
                      <img src="img/spark-logo-hd.png" style="height:50px;"/></a><span class="version">2.4.3</span>
                    </div>
                    <ul class="nav">
                        <!--TODO(andyk): Add class="active" attribute to li some how.-->
                        <li><a href="index.html">개요</a></li>

                        <li class="dropdown">
                            <a href="#" class="dropdown-toggle" data-toggle="dropdown">프로그래밍 가이드<b class="caret"></b></a>
                            <ul class="dropdown-menu">
                                <li><a href="quick-start.html">빠른 시작</a></li>
                                <li><a href="sql-programming-guide.html">스파크 SQL, DataFrame, Dataset</a></li>
                                <li><a href="structured-streaming-programming-guide.html">구조적 스트리밍</a></li>
                            </ul>
                        </li>

                        <li class="dropdown">
                            <a href="#" class="dropdown-toggle" data-toggle="dropdown">API 문서<b class="caret"></b></a>
                            <ul class="dropdown-menu">
                                <li><a href="https://spark.apache.org/docs/latest/api/scala/index.html#org.apache.spark.package">Scala</a></li>
                                <li><a href="https://spark.apache.org/docs/latest/api/java/index.html">Java</a></li>
                                <li><a href="https://spark.apache.org/docs/latest/api/python/index.html">Python</a></li>
                                <li><a href="https://spark.apache.org/docs/latest/api/R/index.html">R</a></li>
                                <li><a href="https://spark.apache.org/docs/latest/api/sql/index.html">Spark SQL 함수</a></li>
                            </ul>
                        </li>
                    </ul>
                    <!--<p class="navbar-text pull-right"><span class="version-text">v2.4.3</span></p>-->
                </div>
            </div>
        </div>

        <div class="container-wrapper">

            
                
                    <div class="left-menu-wrapper">
    <div class="left-menu">
        <h3><a href="sql-programming-guide.html">Spark SQL Guide</a></h3>
        
<ul>

    <li>
        <a href="sql-getting-started.html">
            
                시작하기
            
        </a>
    </li>
    
    

    <li>
        <a href="sql-data-sources.html">
            
                데이터 소스
            
        </a>
    </li>
    
    
        
<ul>

    <li>
        <a href="sql-data-sources-load-save-functions.html">
            
                일반 불러오기/저장하기 함수
            
        </a>
    </li>
    
    

    <li>
        <a href="sql-data-sources-parquet.html">
            
                <b>Parquet 파일</b>
            
        </a>
    </li>
    
    

    <li>
        <a href="sql-data-sources-orc.html">
            
                ORC 파일
            
        </a>
    </li>
    
    

    <li>
        <a href="sql-data-sources-json.html">
            
                JSON 파일
            
        </a>
    </li>
    
    

    <li>
        <a href="sql-data-sources-hive-tables.html">
            
                Hive 테이블
            
        </a>
    </li>
    
    

    <li>
        <a href="sql-data-sources-jdbc.html">
            
                JDBC를 통한 다른 데이터베이스 사용하기
            
        </a>
    </li>
    
    

    <li>
        <a href="sql-data-sources-avro.html">
            
                Avro 파일
            
        </a>
    </li>
    
    

    <li>
        <a href="sql-data-sources-troubleshooting.html">
            
                문제 해결
            
        </a>
    </li>
    
    

</ul>

    

    <li>
        <a href="sql-performance-tuning.html">
            
                성능 튜닝
            
        </a>
    </li>
    
    

    <li>
        <a href="sql-distributed-sql-engine.html">
            
                분산 SQL 엔진
            
        </a>
    </li>
    
    

    <li>
        <a href="sql-pyspark-pandas-with-arrow.html">
            
                아파치 애로우(Arrow)와 Pandas를 위한 PySpark 사용 가이드
            
        </a>
    </li>
    
    

    <li>
        <a href="sql-reference.html">
            
                참조
            
        </a>
    </li>
    
    

</ul>

    </div>
</div>
                
                <input id="nav-trigger" class="nav-trigger" checked type="checkbox">
                <label for="nav-trigger"></label>
                <div class="content-with-sidebar" id="content">
                    
                        <h1 class="title">Parquet 파일</h1>
                    

                    <ul id="markdown-toc">
  <li><a href="#프로그램에서-데이터-불러오기" id="markdown-toc-프로그램에서-데이터-불러오기">프로그램에서 데이터 불러오기</a></li>
  <li><a href="#파티션partition-탐색" id="markdown-toc-파티션partition-탐색">파티션(Partition) 탐색</a></li>
  <li><a href="#스키마-병합" id="markdown-toc-스키마-병합">스키마 병합</a></li>
  <li><a href="#hive-메타스토어의-parquet-테이블-변환" id="markdown-toc-hive-메타스토어의-parquet-테이블-변환">Hive 메타스토어의 Parquet 테이블 변환</a>    <ul>
      <li><a href="#hiveparquet-스키마-재조합" id="markdown-toc-hiveparquet-스키마-재조합">Hive/Parquet 스키마 재조합</a></li>
      <li><a href="#메타데이터-갱신" id="markdown-toc-메타데이터-갱신">메타데이터 갱신</a></li>
    </ul>
  </li>
  <li><a href="#설정" id="markdown-toc-설정">설정</a></li>
</ul>

<p><a href="http://parquet.io">Parquet(&#8216;파케이&#8217;)</a>는 다양한 데이터 처리 시스템에서 사용하는 컬럼 기반 형식입니다. 스파크 SQL은 자동으로 기존 데이터의 스키마를 유지하는 Parquet 파일의 읽기와 쓰기를 지원합니다. Parquet 파일을 쓸 때, 모든 컬럼은 호환성을 위해 자동으로 null을 허용하도록 변경됩니다.</p>

<h3 id="프로그램에서-데이터-불러오기">프로그램에서 데이터 불러오기</h3>

<p>주: 위 예제에서의 데이터를 사용합니다.</p>

<div class="codetabs">

<div data-lang="scala">
    <div class="highlight"><pre><span></span><span class="c1">// 일반적인 타입에 대한 인코더는 spark.implicits._ 를 import 함으로써 사용할 수 있습니다.</span>
<span class="k">import</span> <span class="nn">spark.implicits._</span>

<span class="k">val</span> <span class="n">peopleDF</span> <span class="k">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">read</span><span class="o">.</span><span class="n">json</span><span class="o">(</span><span class="s">&quot;examples/src/main/resources/people.json&quot;</span><span class="o">)</span>

<span class="c1">// DataFrame은 스키마 정보를 유지하면서 Parquet 파일로 저장할 수 있습니다.</span>
<span class="n">peopleDF</span><span class="o">.</span><span class="n">write</span><span class="o">.</span><span class="n">parquet</span><span class="o">(</span><span class="s">&quot;people.parquet&quot;</span><span class="o">)</span>

<span class="c1">// 위에서 생성한 parquet 파일을 읽습니다.</span>
<span class="c1">// parquet 파일에는 스키마 정보가 포함되어 있습니다. 따라서 위에서 읽어온 스키마는 그대로 보존됩니다.</span>
<span class="c1">// parquet 파일을 불러온 결과 역시 DataFrame이 됩니다.</span>
<span class="k">val</span> <span class="n">parquetFileDF</span> <span class="k">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">read</span><span class="o">.</span><span class="n">parquet</span><span class="o">(</span><span class="s">&quot;people.parquet&quot;</span><span class="o">)</span>

<span class="c1">// parquet 파일은 임시 뷰를 생성하고 SQL문을 실행하는데 사용할 수 있습니다.</span>
<span class="n">parquetFileDF</span><span class="o">.</span><span class="n">createOrReplaceTempView</span><span class="o">(</span><span class="s">&quot;parquetFile&quot;</span><span class="o">)</span>
<span class="k">val</span> <span class="n">namesDF</span> <span class="k">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">sql</span><span class="o">(</span><span class="s">&quot;SELECT name FROM parquetFile WHERE age BETWEEN 13 AND 19&quot;</span><span class="o">)</span>
<span class="n">namesDF</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">attributes</span> <span class="k">=&gt;</span> <span class="s">&quot;Name: &quot;</span> <span class="o">+</span> <span class="n">attributes</span><span class="o">(</span><span class="mi">0</span><span class="o">)).</span><span class="n">show</span><span class="o">()</span>
<span class="c1">// +------------+</span>
<span class="c1">// |       value|</span>
<span class="c1">// +------------+</span>
<span class="c1">// |Name: Justin|</span>
<span class="c1">// +------------+</span>
</pre></div>
    <div><small>스파크 저장소의 "examples/src/main/scala/org/apache/spark/examples/sql/SQLDataSourceExample.scala"에서 전체 예제 코드를 볼 수 있습니다.</small></div>
  </div>

<div data-lang="python">

    <div class="highlight"><pre><span></span><span class="n">peopleDF</span> <span class="o">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">read</span><span class="o">.</span><span class="n">json</span><span class="p">(</span><span class="s2">&quot;examples/src/main/resources/people.json&quot;</span><span class="p">)</span>

<span class="c1"># DataFrame은 스키마 정보를 유지하면서 Parquet 파일로 저장할 수 있습니다.</span>
<span class="n">peopleDF</span><span class="o">.</span><span class="n">write</span><span class="o">.</span><span class="n">parquet</span><span class="p">(</span><span class="s2">&quot;people.parquet&quot;</span><span class="p">)</span>

<span class="c1"># 위에서 생성한 parquet 파일을 읽습니다.</span>
<span class="c1"># parquet 파일에는 스키마 정보가 포함되어 있습니다. 따라서 위에서 읽어온 스키마는 그대로 보존됩니다.</span>
<span class="c1"># parquet 파일을 불러온 결과 역시 DataFrame이 됩니다.</span>
<span class="n">parquetFile</span> <span class="o">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">read</span><span class="o">.</span><span class="n">parquet</span><span class="p">(</span><span class="s2">&quot;people.parquet&quot;</span><span class="p">)</span>

<span class="c1"># parquet 파일은 임시 뷰를 생성하고 SQL문을 실행하는데 사용할 수 있습니다.</span>
<span class="n">parquetFile</span><span class="o">.</span><span class="n">createOrReplaceTempView</span><span class="p">(</span><span class="s2">&quot;parquetFile&quot;</span><span class="p">)</span>
<span class="n">teenagers</span> <span class="o">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">sql</span><span class="p">(</span><span class="s2">&quot;SELECT name FROM parquetFile WHERE age &gt;= 13 AND age &lt;= 19&quot;</span><span class="p">)</span>
<span class="n">teenagers</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<span class="c1"># +------+</span>
<span class="c1"># |  name|</span>
<span class="c1"># +------+</span>
<span class="c1"># |Justin|</span>
<span class="c1"># +------+</span>
</pre></div>
    <div><small>스파크 저장소의 "examples/src/main/python/sql/datasource.py"에서 전체 예제 코드를 볼 수 있습니다.</small></div>
  </div>

<div data-lang="sql">

    <figure class="highlight"><pre><code class="language-sql" data-lang="sql"><span></span><span class="k">CREATE</span> <span class="k">TEMPORARY</span> <span class="k">VIEW</span> <span class="n">parquetTable</span>
<span class="k">USING</span> <span class="n">org</span><span class="p">.</span><span class="n">apache</span><span class="p">.</span><span class="n">spark</span><span class="p">.</span><span class="k">sql</span><span class="p">.</span><span class="n">parquet</span>
<span class="k">OPTIONS</span> <span class="p">(</span>
  <span class="n">path</span> <span class="ss">&quot;examples/src/main/resources/people.parquet&quot;</span>
<span class="p">)</span>

<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">parquetTable</span></code></pre></figure>

  </div>

</div>

<h3 id="파티션partition-탐색">파티션(Partition) 탐색</h3>

<p>테이블의 내용을 일정한 형태로 분할해서 저장하는 테이블 파티셔닝은 Hive와 같은 시스템에서 일반적으로 사용되는 최적화 방법입니다. 분할된 테이블에서 각 데이터는 일반적으로 다른 디렉토리에 저장되며 각 분할 디렉토리의 경로는 분할 컬럼의 값으로 인코딩됩니다. 모든 내장 파일 소스(Text/CSV/JSON/ORC/Parquet)는 자동으로 분할 정보를 탐색하거나 유추합니다. 예를 들어 우리가 이전에 사용했던 인구 데이터를 아래의 디렉토리 구조를 따라 분할된 테이블로 저장할 수 있습니다. <code>gender</code>와 <code>country는</code> 별도의 두 분할 컬럼으로 사용할 수 있습니다:</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text"><span></span>path
└── to
    └── table
        ├── gender=male
        │   ├── ...
        │   │
        │   ├── country=US
        │   │   └── data.parquet
        │   ├── country=CN
        │   │   └── data.parquet
        │   └── ...
        └── gender=female
            ├── ...
            │
            ├── country=US
            │   └── data.parquet
            ├── country=CN
            │   └── data.parquet
            └── ...</code></pre></figure>

<p><code>SparkSession.read.parquet</code> 또는 <code>SparkSession.read.load</code>에 <code>path/to/table</code>을 넣어주면 스파크 SQL은 자동으로 해당 경로를 통해 분할 정보를 추출합니다. 반환되는 DataFrame의 스키마는 다음과 같습니다:</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text"><span></span>root
|-- name: string (nullable = true)
|-- age: long (nullable = true)
|-- gender: string (nullable = true)
|-- country: string (nullable = true)</code></pre></figure>

<p>파티션 컬럼의 데이터 타입은 자동으로 추론된다는 점을 명심하시기 바랍니다. 현재 날짜, 시간, 숫자 타입, 문자열 타입이 지원됩니다. 자동 데이터 타입 추론을 것을 원치 않을 경우에는 <code>spark.sql.sources.partitionColumnTypeInference.enabled</code> 설정값을 바꿔 주면 됩니다. (기본값: true.) 자동 타입 유추가 비활성화되면 파티션 컬럼은 문자열 타입으로 간주됩니다.</p>

<p>스파크 1.6.0 버전부터, 파티션 탐색은 기본적으로 주어진 경로의 파티션만 구별해냅니다. 위의 예제에서, <code>SparkSession.read.parquet</code>나 <code>SparkSession.read.load</code>에 <code>genderpath/to/table/gender=male</code>를 입력하면 파티션 컬럼은 적용되지 않습니다. 만약 사용자가 분할 탐색을 시작할 경로를 명시해야 한다면 데이터 소스 옵션에서 <code>basePath</code>를 설정할 수 있습니다. 예를 들어 데이터 경로가 <code>path/to/table/gender=male</code>인 경우 사용자는 <code>basePath</code>를 <code>path/to/table/</code>으로 설정하면 <code>gender</code>가 분할 컬럼이 됩니다.</p>

<h3 id="스키마-병합">스키마 병합</h3>

<p>Protocol Buffer, Avro 그리고 Thrift와 마찬가지로, Parquet 또한 스키마를 변경할 수 있습니다. 사용자는 간단한 스키마로 시작하여 필요한 경우 스키마에 컬럼을 더 추가할 수 있습니다. 이것을 위해서 사용자는 서로 호환할 수 있는 스키마를 가진 여러 개의 다른 Parquet 파일을 사용할 수 있습니다. Parquet 데이터 소스는 이러한 파일을 자동으로 감지하고 스키마를 병합합니다.</p>

<p>스키마 병합은 상대적으로 고비용의 연산이기 때문에 대부분의 경우 필수적이진 않습니다. 1.5.0 버전부터는 이 기능은 기본적으로 비활성화되어있습니다. 이 기능을 활성화시키기 위해서는</p>

<ol>
  <li>(아래의 예제와 같이) Parquet 파일을 읽어올 때 데이터 소스의 옵션 <code>mergeSchema</code>을 <code>true</code>로 설정하거나,</li>
  <li>전역 SQL 옵션 <code>spark.sql.parquet.mergeSchema</code>을 <code>true</code>로 설정합니다.</li>
</ol>

<div class="codetabs">

<div data-lang="scala">
    <div class="highlight"><pre><span></span><span class="c1">// RDD를 DataFrame으로 변환하기 위해 사용됩니다.</span>
<span class="k">import</span> <span class="nn">spark.implicits._</span>

<span class="c1">// 간단한 DataFrame을 생성하고 파티션 디렉토리에 저장합니다.</span>
<span class="k">val</span> <span class="n">squaresDF</span> <span class="k">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">sparkContext</span><span class="o">.</span><span class="n">makeRDD</span><span class="o">(</span><span class="mi">1</span> <span class="n">to</span> <span class="mi">5</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">i</span> <span class="o">*</span> <span class="n">i</span><span class="o">)).</span><span class="n">toDF</span><span class="o">(</span><span class="s">&quot;value&quot;</span><span class="o">,</span> <span class="s">&quot;square&quot;</span><span class="o">)</span>
<span class="n">squaresDF</span><span class="o">.</span><span class="n">write</span><span class="o">.</span><span class="n">parquet</span><span class="o">(</span><span class="s">&quot;data/test_table/key=1&quot;</span><span class="o">)</span>

<span class="c1">// 새로운 컬럼을 추가하고 기존의 컬럼을 삭제함으로써 또 다른 DataFrame을 생성하고,</span>
<span class="c1">// 새로운 분할 디렉토리에 저장합니다.</span>
<span class="k">val</span> <span class="n">cubesDF</span> <span class="k">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">sparkContext</span><span class="o">.</span><span class="n">makeRDD</span><span class="o">(</span><span class="mi">6</span> <span class="n">to</span> <span class="mi">10</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">i</span> <span class="o">*</span> <span class="n">i</span> <span class="o">*</span> <span class="n">i</span><span class="o">)).</span><span class="n">toDF</span><span class="o">(</span><span class="s">&quot;value&quot;</span><span class="o">,</span> <span class="s">&quot;cube&quot;</span><span class="o">)</span>
<span class="n">cubesDF</span><span class="o">.</span><span class="n">write</span><span class="o">.</span><span class="n">parquet</span><span class="o">(</span><span class="s">&quot;data/test_table/key=2&quot;</span><span class="o">)</span>

<span class="c1">// 분할된 테이블을 읽어옵니다.</span>
<span class="k">val</span> <span class="n">mergedDF</span> <span class="k">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">read</span><span class="o">.</span><span class="n">option</span><span class="o">(</span><span class="s">&quot;mergeSchema&quot;</span><span class="o">,</span> <span class="s">&quot;true&quot;</span><span class="o">).</span><span class="n">parquet</span><span class="o">(</span><span class="s">&quot;data/test_table&quot;</span><span class="o">)</span>
<span class="n">mergedDF</span><span class="o">.</span><span class="n">printSchema</span><span class="o">()</span>

<span class="c1">// The final schema consists of all 3 columns in the Parquet files together</span>
<span class="c1">// with the partitioning column appeared in the partition directory paths</span>
<span class="c1">// 최종 스키마는 Parquet 파일에 들어 있는 세 개의 컬럼과</span>
<span class="c1">// 파티션 디렉토리 경로에 나타나는 파티션 컬럼, 모두 네 개의 컬럼으로 이루어집니다.</span>
<span class="c1">// root</span>
<span class="c1">//  |-- value: int (nullable = true)</span>
<span class="c1">//  |-- square: int (nullable = true)</span>
<span class="c1">//  |-- cube: int (nullable = true)</span>
<span class="c1">//  |-- key: int (nullable = true)</span>
</pre></div>
    <div><small>스파크 저장소의 "examples/src/main/scala/org/apache/spark/examples/sql/SQLDataSourceExample.scala"에서 전체 예제 코드를 볼 수 있습니다.</small></div>
  </div>

<div data-lang="python">

    <div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyspark.sql</span> <span class="kn">import</span> <span class="n">Row</span>

<span class="c1"># spark는 이전 예제에서 나온 것입니다.</span>
<span class="c1"># 간단한 DataFrame을 생성하고 분할 디렉토리에 저장합니다.</span>
<span class="n">sc</span> <span class="o">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">sparkContext</span>

<span class="n">squaresDF</span> <span class="o">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">createDataFrame</span><span class="p">(</span><span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
                                  <span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">Row</span><span class="p">(</span><span class="n">single</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">double</span><span class="o">=</span><span class="n">i</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)))</span>
<span class="n">squaresDF</span><span class="o">.</span><span class="n">write</span><span class="o">.</span><span class="n">parquet</span><span class="p">(</span><span class="s2">&quot;data/test_table/key=1&quot;</span><span class="p">)</span>

<span class="c1"># 새로운 컬럼을 추가하고 기존의 컬럼을 삭제함으로써 또 다른 DataFrame을 생성하고,</span>
<span class="c1"># 새로운 분할 디렉토리에 저장합니다.</span>
<span class="n">cubesDF</span> <span class="o">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">createDataFrame</span><span class="p">(</span><span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">11</span><span class="p">))</span>
                                <span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">Row</span><span class="p">(</span><span class="n">single</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">triple</span><span class="o">=</span><span class="n">i</span> <span class="o">**</span> <span class="mi">3</span><span class="p">)))</span>
<span class="n">cubesDF</span><span class="o">.</span><span class="n">write</span><span class="o">.</span><span class="n">parquet</span><span class="p">(</span><span class="s2">&quot;data/test_table/key=2&quot;</span><span class="p">)</span>

<span class="c1"># 분할된 테이블을 읽어옵니다.</span>
<span class="n">mergedDF</span> <span class="o">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">read</span><span class="o">.</span><span class="n">option</span><span class="p">(</span><span class="s2">&quot;mergeSchema&quot;</span><span class="p">,</span> <span class="s2">&quot;true&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">parquet</span><span class="p">(</span><span class="s2">&quot;data/test_table&quot;</span><span class="p">)</span>
<span class="n">mergedDF</span><span class="o">.</span><span class="n">printSchema</span><span class="p">()</span>

<span class="c1"># 최종 스키마는 Parquet 파일에 들어 있는 세 개의 컬럼과</span>
<span class="c1"># 파티션 디렉토리 경로에 나타나는 파티션 컬럼, 모두 네 개의 컬럼으로 이루어집니다.</span>
<span class="c1"># root</span>
<span class="c1">#  |-- double: long (nullable = true)</span>
<span class="c1">#  |-- single: long (nullable = true)</span>
<span class="c1">#  |-- triple: long (nullable = true)</span>
<span class="c1">#  |-- key: integer (nullable = true)</span>
</pre></div>
    <div><small>스파크 저장소의 "examples/src/main/python/sql/datasource.py"에서 전체 예제 코드를 볼 수 있습니다.</small></div>
  </div>

</div>

<h3 id="hive-메타스토어의-parquet-테이블-변환">Hive 메타스토어의 Parquet 테이블 변환</h3>

<p>Hive 메타스토어의 Parquet 테이블을 읽거나 쓸 때, 스파크 SQL은 Hive SerDe를 사용하는 것보다 더 나은 성능을 위하여 자체적으로 포함된 Parquet 기능을 사용합니다. 이 기능은 기본적으로 활성화되어 있으며 <code>spark.sql.hive.convertMetastoreParquet</code>에서 설정할 수 있습니다.</p>

<h4 id="hiveparquet-스키마-재조합">Hive/Parquet 스키마 재조합</h4>

<p>테이블 스키마 처리의 관점에서 Hive와 Parquet 사이에는 두 가지 중요한 차이점이 있습니다.</p>

<ol>
  <li>Hive는 대소문자를 구분하지 않지만, Parquet는 구분합니다.</li>
  <li>Hive는 모든 컬럼이 null 값을 가질 수 있지만 Parquet에서는 null 값을 가질 수도있고 그렇지 않을 수도 있습니다.</li>
</ol>

<p>이러한 이유 때문에 Hive 메타스토어의 Parque 테이블을 스파크 SQL의 Parquet 테이블로 변환할 때 Hive 메타스토어 스키마를 Parquet 스키마와 적절하게 조합해야 합니다. 조합 규칙은 다음과 같습니다:</p>

<ol>
  <li>
    <p>두 스키마에서 동일한 이름을 가지는 필드는 null 값을 가질 수 있는지에 상관없이 항상 동일한 데이터 타입을 가져야 합니다. 조합된 필드는 Parquet의 데이터 타입을 가져야 하고 null 값을 가질 수 있어야 합니다.</p>
  </li>
  <li>
    <p>조합된 스키마는 Hive 메타스토어에서 정의된 필드만을 포함해야 합니다.</p>

    <ul>
      <li>Parquet 스키마에서만 존재했던 필드는 재조합된 스키마에서는 삭제됩니다.</li>
      <li>Hive 메타스토어에서만 존재했던 필드는 조합된 스키마에 null 값을 가질 수 있는 필드로 추가됩니다.</li>
    </ul>
  </li>
</ol>

<h4 id="메타데이터-갱신">메타데이터 갱신</h4>

<p>스파크 SQL은 성능 향상을 위해 Parquet 메타데이터를 캐시합니다. Hive 메타스토어 Parquet 테이블의 변환이 활성화되어 있을 때, 이 변환된 테이블의 메타데이터 또한 캐시됩니다. 이 테이블이 Hive나 다른 외부의 도구에 의해 업데이트되면, 이를 수동으로 새로고침하여 메타데이터를 일관되게 유지해야 합니다.</p>

<div class="codetabs">

<div data-lang="scala">

    <figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span></span><span class="c1">// spark는 이미 존재하는 SparkSession입니다.</span>
<span class="n">spark</span><span class="o">.</span><span class="n">catalog</span><span class="o">.</span><span class="n">refreshTable</span><span class="o">(</span><span class="s">&quot;my_table&quot;</span><span class="o">)</span></code></pre></figure>

  </div>

<div data-lang="python">

    <figure class="highlight"><pre><code class="language-python" data-lang="python"><span></span><span class="c1"># spark는 이미 존재하는 SparkSession입니다</span></code></pre></figure>

  </div>

<div data-lang="sql">

    <figure class="highlight"><pre><code class="language-sql" data-lang="sql"><span></span><span class="n">REFRESH</span> <span class="k">TABLE</span> <span class="n">my_table</span><span class="p">;</span></code></pre></figure>

  </div>

</div>

<h3 id="설정">설정</h3>

<p>Parquet 설정은 <code>SparkSession</code>에서<code> setConf</code> 메소드를 사용하거나 SQL에서 <code>SET key=value</code> 명령어를 실행하여 설정할 수 있습니다.</p>

<table class="table">
<tr><th>속성 이름</th><th>기본값</th><th>의미</th></tr>
<tr>
  <td><code>spark.sql.parquet.binaryAsString</code></td>
  <td>false</td>
  <td>
    Impala, Hive, 구버전의 스파크 SQL과 같이 Parquet를 생성하는 몇몇 시스템에서는 Parquet 스키마를 쓸 때 바이너리 데이터와 문자열을 구분하지 않습니다. 이 플래그는 스파크 SQL이 바이너리 데이터를 문자열로 인식하도록 하는 호환성을 의미합니다.
  </td>
</tr>
<tr>
  <td><code>spark.sql.parquet.int96AsTimestamp</code></td>
  <td>true</td>
  <td>
    Impala, Hive와 같이 Parquet를 생성하는 시스템에서는 타임스탬프를 INT96으로 저장합니다. 이 플래그는 스파크 SQL이 INT96 데이터를 timestamp로 인식하도록 하는 호환성을 의미합니다.
  </td>
</tr>
<tr>
  <td><code>spark.sql.parquet.compression.codec</code></td>
  <td>snappy</td>
  <td>
    Parquet 파일을 쓸 때 사용할 압축 코덱을 설정합니다. 테이블 옵션/속성에 `compression` 또는 `parquet.compression` 속성이 이미 명시되어 있다면, 우선순위는 `compression`, `parquet.compression`, `spark.sql.parquet.compression.codec`순이 됩니다. 지원 가능한 코덱은 다음과 같습니다: none, uncompressed, snappy, gzip, lzo, brotli, lz4, zstd.
    Hadoop 2.9.0 이하 버전에서는 `zstd`를 사용하기 위해서는 `ZStandardCodec`를 설치해야 합니다. `brotli`를 사용하기 위해서는 `BrotliCodec`를 설치해야 합니다.
  </td>
</tr>
<tr>
  <td><code>spark.sql.parquet.filterPushdown</code></td>
  <td>true</td>
  <td>true로 설정되었을 때, Parquet 필터 푸쉬다운 최적화를 활성화합니다.</td>
</tr>
<tr>
  <td><code>spark.sql.hive.convertMetastoreParquet</code></td>
  <td>true</td>
  <td>
    false로 설정되었을 때, 스파크 SQL은 parquet 테이블을 다룰 때 내장된 기능 대신 Hive SerDe를 사용합니다.
  </td>
</tr>
<tr>
  <td><code>spark.sql.parquet.mergeSchema</code></td>
  <td>false</td>
  <td>
    <p>
      true로 설정되었을 때, Parquet 데이터 소스는 모든 데이터 파일의 스키마를 병합합니다. false로 설정되었을 때는 요약 파일에서 요약된 파일이 없는 경우 임의로 데이터 파일로부터, 스키마를 생성합니다.
    </p>
  </td>
</tr>
<tr>
  <td><code>spark.sql.parquet.writeLegacyFormat</code></td>
  <td>false</td>
  <td>
    true로 설정되었을 때, 데이터는 Spark 1.4 이하 버전에서처럼 쓰여집니다. 예를 들어 decimal 값은 아파치 Hive와 Impala와 마찬가지로 아파치 Parquet의 고정 길이 바이트 배열 형식으로 쓰여집니다. false로 설정되면 Parquet의 새로운 형식이 사용됩니다. 예를 들어 decimal는 정수 기반 형식으로 쓰여집니다. 만약 Parquet 출력값이 새로운 형식을 사용하지 않도록 하려면 true로 설정하여야 합니다.
  </td>
</tr>
</table>


                </div>
            
             <!-- /container -->
        </div>

        <script src="js/vendor/jquery-1.12.4.min.js"></script>
        <script src="js/vendor/bootstrap.min.js"></script>
        <script src="js/vendor/anchor.min.js"></script>
        <script src="js/main.js"></script>

        <!-- MathJax Section -->
        <script type="text/x-mathjax-config">
            MathJax.Hub.Config({
                TeX: { equationNumbers: { autoNumber: "AMS" } }
            });
        </script>
        <script>
            // Note that we load MathJax this way to work with local file (file://), HTTP and HTTPS.
            // We could use "//cdn.mathjax...", but that won't support "file://".
            (function(d, script) {
                script = d.createElement('script');
                script.type = 'text/javascript';
                script.async = true;
                script.onload = function(){
                    MathJax.Hub.Config({
                        tex2jax: {
                            inlineMath: [ ["$", "$"], ["\\\\(","\\\\)"] ],
                            displayMath: [ ["$$","$$"], ["\\[", "\\]"] ],
                            processEscapes: true,
                            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre']
                        }
                    });
                };
                script.src = ('https:' == document.location.protocol ? 'https://' : 'http://') +
                    'cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js' +
                    '?config=TeX-AMS-MML_HTMLorMML';
                d.getElementsByTagName('head')[0].appendChild(script);
            }(document));
        </script>
    </body>
</html>
